"""Autogenerated SQLAlchemy models based on OpenAlchemy models."""
# pylint: disable=no-member,super-init-not-called,unused-argument

import datetime
import typing

import sqlalchemy
from sqlalchemy import orm

from open_alchemy import models

Base = models.Base  # type: ignore


class _UserDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    id: str
    first_name: str
    last_name: str
    tel: str
    created_at: str
    updated_at: str


class UserDict(_UserDictBase, total=False):
    """TypedDict for properties that are not required."""

    email: typing.Optional[str]
    affiliate: typing.Optional["AffiliateDict"]


class TUser(typing.Protocol):
    """
    SQLAlchemy model protocol.

    担当者

    Attrs:
        id: ユーザID
        first_name: 名
        last_name: 姓
        tel: 電話番号
        email: メールアドレス
        created_at: 作成日
        updated_at: 更新日
        affiliate: The affiliate of the User.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[str]'
    first_name: 'sqlalchemy.Column[str]'
    last_name: 'sqlalchemy.Column[str]'
    tel: 'sqlalchemy.Column[str]'
    email: 'sqlalchemy.Column[typing.Optional[str]]'
    created_at: 'sqlalchemy.Column[datetime.datetime]'
    updated_at: 'sqlalchemy.Column[datetime.datetime]'
    affiliate: 'sqlalchemy.Column[typing.Optional["TAffiliate"]]'

    def __init__(self, id: str, first_name: str, last_name: str, tel: str, created_at: datetime.datetime, updated_at: datetime.datetime, email: typing.Optional[str] = None, affiliate: typing.Optional["TAffiliate"] = None) -> None:
        """
        Construct.

        Args:
            id: ユーザID
            first_name: 名
            last_name: 姓
            tel: 電話番号
            email: メールアドレス
            created_at: 作成日
            updated_at: 更新日
            affiliate: The affiliate of the User.

        """
        ...

    @classmethod
    def from_dict(cls, id: str, first_name: str, last_name: str, tel: str, created_at: datetime.datetime, updated_at: datetime.datetime, email: typing.Optional[str] = None, affiliate: typing.Optional["AffiliateDict"] = None) -> "TUser":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: ユーザID
            first_name: 名
            last_name: 姓
            tel: 電話番号
            email: メールアドレス
            created_at: 作成日
            updated_at: 更新日
            affiliate: The affiliate of the User.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TUser":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> UserDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


User: typing.Type[TUser] = models.User  # type: ignore


class _AffiliateDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    id: str
    name: str
    postcode: str
    address: str
    tel: str
    created_at: str
    updated_at: str


class AffiliateDict(_AffiliateDictBase, total=False):
    """TypedDict for properties that are not required."""

    fax: typing.Optional[str]
    email: typing.Optional[str]


class TAffiliate(typing.Protocol):
    """
    SQLAlchemy model protocol.

    加盟組織

    Attrs:
        id: 加盟組織ID
        name: 組織名
        postcode: 郵便番号
        address: 住所
        tel: 電話番号
        fax: FAX番号
        email: メールアドレス
        created_at: 作成日
        updated_at: 更新日
        users: The users of the Affiliate.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[str]'
    name: 'sqlalchemy.Column[str]'
    postcode: 'sqlalchemy.Column[str]'
    address: 'sqlalchemy.Column[str]'
    tel: 'sqlalchemy.Column[str]'
    fax: 'sqlalchemy.Column[typing.Optional[str]]'
    email: 'sqlalchemy.Column[typing.Optional[str]]'
    created_at: 'sqlalchemy.Column[datetime.datetime]'
    updated_at: 'sqlalchemy.Column[datetime.datetime]'
    users: 'sqlalchemy.Column[typing.Sequence["TUser"]]'

    def __init__(self, id: str, name: str, postcode: str, address: str, tel: str, created_at: datetime.datetime, updated_at: datetime.datetime, fax: typing.Optional[str] = None, email: typing.Optional[str] = None, users: typing.Optional[typing.Sequence["TUser"]] = None) -> None:
        """
        Construct.

        Args:
            id: 加盟組織ID
            name: 組織名
            postcode: 郵便番号
            address: 住所
            tel: 電話番号
            fax: FAX番号
            email: メールアドレス
            created_at: 作成日
            updated_at: 更新日
            users: The users of the Affiliate.

        """
        ...

    @classmethod
    def from_dict(cls, id: str, name: str, postcode: str, address: str, tel: str, created_at: datetime.datetime, updated_at: datetime.datetime, fax: typing.Optional[str] = None, email: typing.Optional[str] = None) -> "TAffiliate":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: 加盟組織ID
            name: 組織名
            postcode: 郵便番号
            address: 住所
            tel: 電話番号
            fax: FAX番号
            email: メールアドレス
            created_at: 作成日
            updated_at: 更新日
            users: The users of the Affiliate.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TAffiliate":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> AffiliateDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Affiliate: typing.Type[TAffiliate] = models.Affiliate  # type: ignore
